# -*- coding: utf-8 -*-
"""[Mar3ng] Ứng dụng Mar

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sdrZQisGPS0hCyQnouA0_fJS_YChLxqd

# **Data Cleaning**

# **Import thư viện**
"""

import pandas as pd
import numpy as np
import scipy.stats
import matplotlib.pyplot as plt
import datetime
import seaborn as sns
from sklearn.metrics.pairwise import cosine_similarity

#Cài đặt thư viện
!pip install mlxtend
!pip install openpyxl
!pip install networkx
from mlxtend.frequent_patterns import apriori, association_rules
import networkx as nx

from google.colab import drive
drive.mount('/content/drive')

"""## **Đọc dữ liệu**"""

df_1 = pd.read_excel("/content/drive/MyDrive/UDMAR/Online Retail.xlsx")
df_1.head(4)

"""## **Kiểm tra thông tin tổng quan**

+ InvoiceNo là số hóa đơn: Đại diện cho mỗi giao dịch mua hàng
+ StockCode là mã sản phẩm: Mã định danh duy nhất cho môi sản phẩm (tức là cùng một stockcode thì sản phẩm đó giống nhau dù được mua ở các đơn hàng khác nhau)
"""

df_1.info()

df_1.isnull().sum()

"""Notes:
+ Dataset có 541909 hàng và 8 cột
+ Các cột không có giá trị null là: InvoiceNo, StockCode, Quantity, InvoiceDate, UnitPrice, Country
+ Các cột có giá trị null: Description, CustomerID
> Kiểm tra Data type:
>> + Đa số data Type của các cột đã phù hợp
>> + Xem lại các giá trị của cột 'InvoiceNo' (object hay int64) ?
>> + Xem lại Data Type của cột CustomerID ?

**Lọc dữ liệu phù hợp với yêu cầu: Nhóm 4 (dataset lấy từ tháng 4 đến tháng 8 năm 2011)**
"""

df_1['Month'] = df_1['InvoiceDate'].dt.month
df_1.head(4)

df_2 = df_1[df_1['Month'].isin([4,5,6,7,8])]
df_2.head(4)

df_2.describe()

"""Notes:
+ Giá trị ở cột Quanity, UnitPrice bị âm (?)
+ Các cột còn lại phù hợp

## **Xử lí dữ liệu thiếu (Missing Values)**

Notes:
+ Có 1,1% dữ liệu bị null trong cột Description
+ Gán giá trị "unknow product" để làm các phân tích dưới (mỗi sản phẩm tương ứng với một mã InvoiceNo riêng biệt)
"""

# Gán "Unknown Product" cho những dòng thiếu Description
df_2['Description'] = df_2['Description'].fillna('Unknown Product')

#Check các hàng có customerID null
df_2[df_2['CustomerID'].isnull()].head(5)

"""Notes: Thấy các hàng khi có customerID null thì các giá trị ở các hàng còn lại vẫn có nhưng cột customer_id bị null sẽ không phù hợp ở các phân tích dưới
> Xóa các hàng có giá trị ở cột CustomerID bị null
"""

df_2 = df_2.dropna(subset=['CustomerID'])

df_2['CustomerID'].isnull().sum()

#Chuyển cột Customer ID lại đúng Data Type
df_2['CustomerID'] = df_2['CustomerID'].astype(str)

"""## **Loại bỏ dữ liệu không hợp lệ**"""

#Check những hàng có giá trị Quantity < 0
df_2[df_2['Quantity'] <= 0]. head(5)
# Có chữ C phía trước là các đơn hàng bị hủy

df = df_2[(df_2['Quantity'] > 0) & (df_2['UnitPrice'] > 0)]

"""## **Mở rộng dữ liệu**"""

#Tạo thêm côt Total Price
df['TotalPrice'] = df['Quantity']*df['UnitPrice']
df.head(2)

df.isnull().sum()

df = df.drop_duplicates() #Loại các dòng trùng lặp (giống nhau ở các cột)
df.info()

from google.colab import drive
drive.mount('/content/drive')

file_path = '/content/drive/MyDrive/cleaned_data_Mar3ng.xlsx'
df.to_excel(file_path, index=False)

"""# **Yêu cầu 1: Khám phá dữ liệu**

## **Top sản phẩm bán chạy**

#### **Cách 1:**
+ Top sản phẩm theo số lượng (xu hướng yêu thích)
+ Top sản phẩm theo doanh thu (sản phẩm mang lại giá trị cao)
"""

df.head(5)

"""**Xét theo Quantity**"""

# Nhóm theo StockCode và tính tổng Quantity bán ra cho mỗi sản phẩm
top_products_by_quantity = df.groupby('StockCode').agg(
    TotalQuantity=('Quantity', 'sum')  # Tính tổng Quantity cho mỗi StockCode
).reset_index()

# Sắp xếp theo Quantity từ cao đến thấp và lấy top 10 sản phẩm
top_10_products = top_products_by_quantity.sort_values('TotalQuantity', ascending=False).head(10)

top_10_products

# Merge với df_2 để lấy thêm thông tin về Description
top_10_products_info = pd.merge(top_10_products, df[['StockCode', 'Description']].drop_duplicates(), on='StockCode', how='left')

# In ra thông tin top 10 sản phẩm bán chạy nhất theo Quantity
print(top_10_products_info[['StockCode', 'Description', 'TotalQuantity']])

# Thiết lập kiểu hiển thị đồ họa
sns.set(style="whitegrid")

# Vẽ bar chart
plt.figure(figsize=(10,6))
sns.barplot(data=top_10_products_info, x='TotalQuantity', y='Description', palette='Blues_d')

# Thêm tiêu đề và nhãn cho đồ thị
plt.title('Top 10 Sản Phẩm Bán Chạy Nhất Theo Số Lượng', fontsize=16)
plt.xlabel('Số Lượng Bán', fontsize=12)
plt.ylabel('Tên Sản Phẩm', fontsize=12)

# Hiển thị đồ thị
plt.show()

"""**Xét theo TotalPrice**"""

# Tính tổng TotalPrice cho mỗi StockCode
top_products_by_totalsales = df.groupby('StockCode').agg(
    TotalSales=('TotalPrice', 'sum')  # Tính tổng TotalPrice cho mỗi StockCode
).reset_index()

# Lấy top 10 sản phẩm có tổng giá trị bán hàng cao nhất
top_10_products_sales = top_products_by_totalsales.sort_values('TotalSales', ascending=False).head(10)

# Kết hợp với thông tin Description từ df
top_10_products_info = pd.merge(top_10_products_sales, df[['StockCode', 'Description']].drop_duplicates(), on='StockCode', how='left')

# In ra kết quả
print(top_10_products_info[['StockCode', 'Description', 'TotalSales']])

# Thiết lập kiểu hiển thị đồ họa
sns.set(style="whitegrid")

# Vẽ bar chart cho top 10 sản phẩm theo TotalSales
plt.figure(figsize=(10,6))
sns.barplot(data=top_10_products_info, x='TotalSales', y='Description', palette='Blues_d')

# Thêm tiêu đề và nhãn cho đồ thị
plt.title('Top 10 Sản Phẩm Bán Chạy Nhất Theo Tổng Giá Trị', fontsize=16)
plt.xlabel('Tổng Giá Trị (Total Sales)', fontsize=12)
plt.ylabel('Tên Sản Phẩm', fontsize=12)

# Hiển thị đồ thị
plt.show()

"""**Xét theo cả 2 yếu tố**"""

# Nhóm theo StockCode và tính tổng Quantity và TotalPrice cho mỗi sản phẩm
df_stock = df.groupby('StockCode').agg(
    TotalQuantity=('Quantity', 'sum'),  # Tổng số lượng bán
    TotalSales=('TotalPrice', 'sum')   # Tổng doanh thu
).reset_index()
df_stock.sort_values('TotalSales', ascending=False).head(5)

# Kết hợp với thông tin Description từ df
top_10_products_both = pd.merge(df_stock, df[['StockCode', 'Description']].drop_duplicates(), on='StockCode', how='left')
top_10_products_both[['StockCode', 'Description', 'TotalSales','TotalQuantity']].sort_values('TotalSales', ascending=False).head(5)

"""**Cách 2:**
> In ra top 5 sản phẩm tính theo mỗi tháng dựa vào doanh thu
"""

df['YearMonth'] = df['InvoiceDate'].dt.to_period('M')
df.head(3)

monthly_revenue = df.groupby(['YearMonth', 'Description'])['TotalPrice'].sum().reset_index()

monthly_revenue['Rank'] = monthly_revenue.groupby('YearMonth')['TotalPrice']\
                                         .rank(method='first', ascending=False)

top3_per_month = monthly_revenue[monthly_revenue['Rank'] <= 3]
top3_per_month.head(20)

# Bước 5: Vẽ biểu đồ
plt.figure(figsize=(12, 6))
sns.barplot(data=top3_per_month, x='YearMonth', y='TotalPrice', hue='Rank', palette='muted')

plt.title("Top 3 sản phẩm theo doanh thu mỗi tháng", fontsize=14)
plt.ylabel("Tổng doanh thu", fontsize=12)
plt.xlabel("Tháng", fontsize=12)
plt.legend(title='Xếp hạng', loc='upper left')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""**Correlation giữa Quanity và TotalSales**"""

correlation = df_stock['TotalQuantity'].corr(df_stock['TotalSales'], method='pearson')
print(f"Độ tương quan Pearson giữa Tổng Số Lượng Bán và Tổng Doanh Thu là: {correlation:.4f}")

# Scatter plot giữa TotalQuantity và TotalSales
plt.figure(figsize=(8,6))
sns.scatterplot(data=df_stock, x='TotalQuantity', y='TotalSales', alpha=0.6)

# Thêm tiêu đề và nhãn cho đồ thị
plt.title('Mối Tương Quan Giữa Tổng Số Lượng Bán và Tổng Doanh Thu (Theo StockCode)', fontsize=16)
plt.xlabel('Tổng Số Lượng Bán (Total Quantity)', fontsize=12)
plt.ylabel('Tổng Doanh Thu (Total Sales)', fontsize=12)

# Hiển thị đồ thị
plt.show()

"""## **Tần suất và giá trị mua hàng trung bình**

### **Cách 1:**
> Dựa trên số InvoiceNo duy nhất (unique)
> Chỉ tính số lần khách hàng thực sự mua hàng, không quan tâm thời gian, miễn là đơn hàng có InvoiceNo khác nhau.
"""

df.head(4)

# Tính tần suất (số lượng InvoiceNo duy nhất) và giá trị mua hàng trung bình
df_customer = df.groupby('CustomerID').agg(
    Frequency=('InvoiceNo', 'nunique'),  # Đếm số lượng InvoiceNo duy nhất
    TotalPrice=('TotalPrice', 'sum')     # Tính tổng giá trị TotalPrice
).reset_index()
df_customer.sort_values(by='Frequency', ascending=False).head(5)

# Tính giá trị mua hàng trung bình (Avg_Monetary)
df_customer['Avg_Monetary'] = df_customer['TotalPrice'] / df_customer['Frequency']
# In ra kết quả (Xếp theo Frequency giảm dần)
print(df_customer[['CustomerID', 'Frequency', 'Avg_Monetary']].sort_values(by='Frequency', ascending=False).head())
# In ra kết quả (Xếp theo Avg_Monetary giảm dần)
print(df_customer[['CustomerID', 'Frequency', 'Avg_Monetary']].sort_values(by='Avg_Monetary',ascending=False).head())

# Vẽ scatter plot giữa Frequency và Avg_Monetary
plt.figure(figsize=(10,6))
sns.scatterplot(data=df_customer, x='Frequency', y='Avg_Monetary')

# Thêm tiêu đề và nhãn
plt.title('Mối Quan Hệ Giữa Tần Suất Mua Hàng và Giá Trị Chi Tiêu Trung Bình', fontsize=16)
plt.xlabel('Tần Suất Mua Hàng', fontsize=12)
plt.ylabel('Giá Trị Chi Tiêu Trung Bình', fontsize=12)

# Hiển thị đồ thị
plt.show()

"""### **Cách 2:**
> Dựa trên số ngày mà khách hàng có giao dịch
> Chỉ quan tâm đến ngày khách quay lại mua, dù một ngày có mua bao nhiêu đơn thì cũng chỉ tính 1 lần.
"""

df.head(2)

df.info()

num_unique_invoices = df['InvoiceNo'].nunique()
print(f"Số lượng giá trị duy nhất trong cột 'InvoiceNo' là: {num_unique_invoices}")
num_unique_customerid = df['CustomerID'].nunique()
print(f"Số lượng giá trị duy nhất trong cột 'CustomerID' là: {num_unique_customerid}")

df_grouped = df[['CustomerID', 'InvoiceNo']].drop_duplicates()
df_grouped = df_grouped.sort_values(by='CustomerID')
df_grouped.head(10)

"""**Các bước làm**"""

# Bước 1: Tạo cột chỉ chứa ngày (bỏ phần giờ phút giây nếu có)
df['InvoiceDay'] = df['InvoiceDate'].dt.date

# Bước 2: Nhóm theo CustomerID và đếm số ngày duy nhất
df_day_freq = df.groupby('CustomerID')['InvoiceDay'].nunique().reset_index()
df_day_freq.head(5)

# Bước 3: Tính tổng chi tiêu (TotalPrice) theo CustomerID
df_total = df.groupby('CustomerID')['TotalPrice'].sum().reset_index()

# Bước 4: Gộp 2 bảng lại để tính giá trị mua hàng trung bình
df_summary = pd.merge(df_day_freq, df_total, on='CustomerID')

# Bước 5: Tính giá trị mua hàng trung bình theo ngày
df_summary['Avg_Monetary_by_day'] = df_summary['TotalPrice'] / df_summary['InvoiceDay']

# Bước 6: Đổi tên cột cho rõ ràng hơn
df_summary.rename(columns={'InvoiceDay': 'Frequency_by_day'}, inplace=True)

# Xem kết quả
df_summary[['CustomerID', 'Frequency_by_day', 'Avg_Monetary_by_day']].sort_values(by='Frequency_by_day', ascending=False).head()

print(df_summary['CustomerID'].dtype)

df_summary['CustomerID'] = df_summary['CustomerID'].astype(float)

df_summary['CustomerID'].isnull().sum()

print("Cách 1 - Tính theo số lượng InvoiceNo:")
print(df_customer[df_customer['CustomerID'] == '17735.0'][['CustomerID', 'Frequency', 'Avg_Monetary']])

print("\nCách 2 - Tính theo số ngày mua:")
print(df_summary[df_summary['CustomerID'] == '17735.0'][['CustomerID', 'Frequency_by_day', 'Avg_Monetary_by_day']])

df[df['CustomerID'] == '17735.0'][['CustomerID','InvoiceNo', 'InvoiceDate', 'TotalPrice']]\
    .drop_duplicates(subset='InvoiceNo')\
    .sort_values('InvoiceDate')\
    .reset_index(drop=True)

"""Notes: Ngày 2011-06-05 khách hàng này mua 2 đơn hàng

# **Yêu cầu 2: Xây dựng hệ thống gợi ý**

## **User-based filtering: Dựa trên khách hàng tương tự**

**Bước 1: Đọc data (đã được làm sạch)**
"""

# Chọn các cột cần thiết
df_yc2 = df[['CustomerID', 'StockCode', 'Quantity']]
df_yc2.head(4)

"""**Bước 2: Tạo ma trận Customer x Item**"""

# Chuyển dữ liệu thành dạng ma trận: Customer x Item
user_item_matrix = df_yc2.pivot_table(index='CustomerID', columns='StockCode', values='Quantity', fill_value=0)
user_item_matrix.head()

"""**Bước 3: Tạo ma trận độ tương quan giữa những người dùng**"""

# Tính độ tương quan giữa những người dùng
user_similarity = user_item_matrix.T.corr()
user_similarity.head()

"""**Bước 4: Xác định những người dùng tương tự**
+ Bây giờ hãy sử dụng người dùng có ID là 18282 làm ví dụ để minh họa cách tìm
những người dùng giống nhau.

+ Loại bỏ người dùng ID 18282 khỏi danh sách người dùng tương tự và xác định số lượng người dùng tương tự cần tìm
"""

#Chọn 1 người dùng bất kỳ
customer_id='18282.0'
# Loại bỏ ID người dùng đấy
user_similarity.drop(index=customer_id, inplace=True)
# Take a look at the data
user_similarity.head()

# Chọn số lượng người dùng tương đồng
n = 5
# User similarity threashold
user_similarity_threshold = 0.3
# Get top n similar users
similar_users = user_similarity[user_similarity[customer_id]>user_similarity_threshold][customer_id].sort_values(ascending=False).iloc[:n]
# Print out top n similar users
print(f'Những người dùng tương đồng với người dùng {customer_id} là', similar_users)

"""**Bước 5: Thu hẹp tập hợp sản phẩm:**

+ Loại bỏ những sản phẩm mà người dùng 18282 đã mua và giữ lại những sản phẩm người dùng tương đồng đã mua
"""

# Xác định sản phẩm mà người dùng đã mua
picked_userid_bought = user_item_matrix[user_item_matrix.index == customer_id]
# Xác định các cột có tất cả giá trị là 0
cols_to_drop = picked_userid_bought.columns[(picked_userid_bought == 0).all()]
# Loại bỏ các sản phẩm mà người dùng 18282 chưa mua
picked_userid_bought = picked_userid_bought.drop(cols_to_drop, axis=1)
picked_userid_bought

# Những sản phẩm mà người dùng tương đồng đã mua
similar_user_items = user_item_matrix[user_item_matrix.index.isin(similar_users.index)]

# Lấy danh sách các cột mà tất cả giá trị đều là 0
cols_to_drop = similar_user_items.columns[(similar_user_items == 0).all()]

# Loại bỏ các sản phẩm mà những người dùng tương đồng chưa mua
similar_user_items = similar_user_items.drop(cols_to_drop, axis=1)
similar_user_items

# Bỏ sản phẩm người dùng đã mua
similar_user_items.drop(picked_userid_bought.columns,axis=1, inplace=True, errors='ignore')
similar_user_items

"""**Bước 6: Đề xuất sản phẩm nào cho người dùng mục tiêu:**

Các mục được đề xuất được xác định dựa điểm gợi ý trung bình cho từng sản phẩm dựa trên số lượng mua và độ tương đồng giữa người dùng. Đoạn mã này sẽ lặp qua các mục và người dùng để tính điểm cho từng sản phẩm, sau đó sắp xếp điểm từ cao đến thấp và chọn ra 10 sản phẩm có điểm cao nhất để đề xuất cho người dùng có ID là 18282.


"""

# Tạo 1 dictionary lưu trữ điểm số dự đoán của từng sản phẩm
item_score = {}
# Tạo vòng lặp sản phẩm
for i in similar_user_items.columns:
  # Số lượng mua của tất cả người dùng tương đồng đối với sản phẩm i
  item_quantity = similar_user_items[i]
  # Tạo 1 biến để tổng hợp số lượng mua
  total = 0
  # Tạo 1 biến để đếm số lượng người dùng đã mua sản phẩm i
  count = 0
  # Tạo vòng lặp người dùng tương đồng
  for u in similar_users.index:
    # Nếu đã mua sản phẩm
    if item_quantity[u] != 0:
      # Tổng điểm tương đồng của người dùng nhân với số lượng mua
      score = similar_users[u] * item_quantity[u]
      # Cộng điểm số vừa tính được vào tổng điểm số của sản phẩm i
      total += score
      # Tăng biến count lên 1
      count +=1
  # Điểm số dự đoán trung bình cho sản phẩm i
  item_score[i] = total / count
# Chuyển dictionary item_score thành một DataFrame Pandas có hai cột: 'StockCode' (chứa StockCode) và 'item_score' (chứa điểm số dự đoán)
item_score = pd.DataFrame(item_score.items(), columns=['StockCode', 'item_score'])

# Sắp xếp DataFrame item_score theo cột 'item_score' theo thứ tự giảm dần
ranked_item_score = item_score.sort_values(by='item_score', ascending=False)
# Chọn top 10 sản phẩm
ranked_item_score = item_score.sort_values(by='item_score', ascending=False).head(10)

# Lấy danh sách StockCode của top 10 sản phẩm
top_10_stock_codes = ranked_item_score['StockCode'].tolist()

# Lấy thông tin Description tương ứng từ DataFrame gốc (df)
top_10_descriptions = df[df['StockCode'].isin(top_10_stock_codes)][['StockCode', 'Description']].drop_duplicates(subset=['StockCode'])
top_10_descriptions = top_10_descriptions.set_index('StockCode')['Description'].to_dict()
# Tạo list Description tương ứng với thứ tự StockCode trong ranked_item_score
recommendation_descriptions = [top_10_descriptions.get(stock_code, 'Không có mô tả') for stock_code in ranked_item_score['StockCode']]
# Thêm cột 'Description' vào ranked_item_score
ranked_item_score.insert(0, 'Description', recommendation_descriptions)
print(ranked_item_score)

"""**Bước 7: Gợi ý 5 sản phẩm cho người dùng**"""

# Lấy top 5 sản phẩm
top_5_ranked_items = ranked_item_score.head(5)
plt.figure(figsize=(10, 6))
sns.barplot(x=top_5_ranked_items['item_score'].values, y=top_5_ranked_items['Description'], palette='coolwarm')
plt.title(f'Top 5 sản phẩm khách {customer_id} nên mua')
plt.xlabel('Số lượng')
plt.ylabel('Tên sản phẩm')
plt.tight_layout()
plt.show()

"""## **Apriori (Market Basket): Gợi ý sản phẩm thường mua kèm**"""

df.head(5)

# Đếm số lượng đơn hàng (InvoiceNo) duy nhất
so_don_hang = df['InvoiceNo'].nunique()
print(f"Tổng số đơn hàng: {so_don_hang}")

# Top 100 sản phẩm xuất hiện nhiều nhât
top_items = df['Description'].value_counts().nlargest(100).index
print(top_items)

"""#### **APRIORI LUẬT KẾT HỢP 2 SẢN PHẨM**"""

# Tạo bảng one-hot encoding cho các sản phẩm theo đơn hàng
basket = (df.groupby(['InvoiceNo', 'StockCode'])['Quantity']
          .sum().unstack().reset_index().fillna(0)
          .set_index('InvoiceNo'))

# Chuyển đổi số lượng thành binary (0 hoặc 1)
basket_sets = basket.applymap(lambda x: 1 if x > 0 else 0)
basket_sets.head(5)

"""Ý nghĩa bước này:
- Mỗi hàng tương ứng với một đơn hàng (InvoiceNo)
- Mỗi cột tương ứng với một sản phẩm (StockCode)
- Giá trị 1 nghĩa là sản phẩm đó xuất hiện trong đơn hàng, 0 nghĩa là không xuất hiện
- Thuật toán Apriori cần dữ liệu ở dạng này để xác định các tập mục phổ biến
"""

# Thử một vài giá trị min_support khác nhau để chọn ra min_support thích hợp
for min_sup in [0.03, 0.02, 0.015]:
    frequent_itemsets = apriori(basket_sets, min_support=min_sup, use_colnames=True)
    print(f"Min support: {min_sup}, số lượng itemset: {len(frequent_itemsets)}")

"""> **Notes**: Min_support là ngưỡng tối thiểu/tỷ lệ tối thiểu số lần một tập hợp sản phẩm (itemset) xuất hiện so với tổng số giỏ hàng."""

# Chọn giá trị min_support = 0.02 và áp dụng Apriori với min_support đã chọn
frequent_itemsets = apriori(basket_sets, min_support=0.02, use_colnames=True)
print(f"Tìm thấy {len(frequent_itemsets)} tập phổ biến")
print(frequent_itemsets.head(10))

# Tạo luật kết hợp với min_confidence = 0.3
rules = association_rules(frequent_itemsets, metric="confidence", min_threshold=0.3)

# Sắp xếp các luật theo lift giảm dần
rules = rules.sort_values('lift', ascending=False)

# Hiển thị 10 luật có lift cao nhất
print(rules.head(10))

# Tạo từ điển ánh xạ mã sản phẩm với tên sản phẩm
product_names = df[['StockCode', 'Description']].drop_duplicates()
product_dict = dict(zip(product_names['StockCode'], product_names['Description']))

# Hàm chuyển đổi từ mã sản phẩm sang tên sản phẩm
def convert_codes_to_names(itemset):
    return tuple(product_dict.get(item, str(item)) for item in itemset)

# Áp dụng cho kết quả
rules['antecedents_names'] = rules['antecedents'].apply(convert_codes_to_names)
rules['consequents_names'] = rules['consequents'].apply(convert_codes_to_names)

# Hiển thị kết quả với tên sản phẩm
print(rules[['antecedents_names', 'consequents_names', 'support', 'confidence', 'lift']].head(10))

# Lọc các luật có lift cao (> 10) và confidence cao (> 0.5)
strong_rules = rules[(rules['lift'] > 10) & (rules['confidence'] > 0.5)]
print(f"Số luật mạnh (lift > 10, confidence > 0.5): {len(strong_rules)}")

# Hiển thị các luật mạnh nhất
print(strong_rules[['antecedents_names', 'consequents_names', 'support', 'confidence', 'lift']].head(10))

"""Dựa vào các luật mạnh trên, mày có thể đưa ra combo gợi ý mua kèm như sau:
1. Combo đĩa Regency:
Nếu khách mua Regency Tea Plate Green, gợi ý thêm Regency Tea Plate Roses (và ngược lại).
Lý do: 2 sản phẩm này thường đi cùng nhau, độ tin cậy cao (~70–89%).

2. Combo túi picnic Paisley:
Gợi ý khách mua cả Scandinavian và Pink Vintage bản túi picnic.
Dễ tạo combo theo phong cách vintage hoặc pastel tone.

3. Combo tách trà Regency:
Nếu khách đã mua Pink Regency Teacup and Saucer, gợi ý bản Green Regency hoặc phiên bản có hoa hồng đi kèm.
"""

top_rules = strong_rules.sort_values(by='confidence', ascending=False).head(10)
plt.figure(figsize=(10,6))
sns.barplot(
    y=top_rules['antecedents_names'].astype(str) + ' → ' + top_rules['consequents_names'].astype(str),
    x=top_rules['confidence'],
    palette="viridis"
)
plt.xlabel('Confidence')
plt.ylabel('Rule')
plt.title('Top 10 Luật kết hợp mạnh (2 sản phẩm)')
plt.tight_layout()
plt.show()

"""#### **APRIORI LUẬT KẾT HỢP 3 SẢN PHẨM**"""

#Lọc luật có đúng 3 sản phẩm (antecedents + consequents = 3)
rules['total_items'] = rules['antecedents'].apply(lambda x: len(x)) + rules['consequents'].apply(lambda x: len(x))
rules_3 = rules[rules['total_items'] == 3]

#Lọc tiếp theo lift nếu muốn
rules_3_strong = rules_3[rules_3['lift'] > 10]

# Xem top 10
rules_3_strong.sort_values(by='confidence', ascending=False).head(10)

#HIỆN TÊN SẢN PHẨM
# Hàm chuyển đổi từ mã sản phẩm sang tên sản phẩm
def convert_codes_to_names(itemset):
    return tuple(product_dict.get(item, str(item)) for item in itemset)

# Áp dụng cho cột 'antecedents' và 'consequents' trong rules_3_strong
rules_3_strong['antecedents_names'] = rules_3_strong['antecedents'].apply(convert_codes_to_names)
rules_3_strong['consequents_names'] = rules_3_strong['consequents'].apply(convert_codes_to_names)

# Hiển thị kết quả với tên sản phẩm
print(rules_3_strong[['antecedents_names', 'consequents_names', 'support', 'confidence', 'lift']].head(10))

# Tạo cột mô tả luật kiểu: Sản phẩm A, B → C
rules_3_strong['rule'] = rules_3_strong['antecedents_names'].apply(lambda x: ', '.join(x)) + ' → ' + \
                         rules_3_strong['consequents_names'].apply(lambda x: ', '.join(x))

# Lấy top 10 luật có confidence cao nhất
top_rules_3 = rules_3_strong.sort_values(by='confidence', ascending=False).head(10)

# Vẽ barplot
plt.figure(figsize=(10, 6))
sns.barplot(data=top_rules_3, y='rule', x='confidence', palette='magma')

plt.xlabel('Độ tin cậy (Confidence)')
plt.ylabel('Luật kết hợp sản phẩm (3 sản phẩm)')
plt.title('Top 10 Gợi ý sản phẩm (3 món đi chung) theo độ tin cậy')
plt.tight_layout()
plt.show()

"""#### **Trực quan hóa**: Vẽ biểu đồ mạng cho sản phẩm thường đi kèm"""

# Khởi tạo đồ thị có hướng
G = nx.DiGraph()

# Duyệt qua các luật kết hợp và thêm các cạnh vào đồ thị
for _, row in rules.iterrows():
    antecedents = list(row['antecedents'])
    consequents = list(row['consequents'])

    # Duyệt qua các sản phẩm trong antecedents và consequents, tạo cạnh giữa chúng
    for a in antecedents:
        for c in consequents:
            G.add_edge(a, c, lift=row['lift'], confidence=row['confidence'])

# Vẽ biểu đồ mạng
plt.figure(figsize=(14, 10))

# Đặt vị trí các node
pos = nx.spring_layout(G, k=0.5, seed=42)  # Layout đẹp

# Lấy trọng số của cạnh từ thuộc tính 'lift'
weights = [d['lift'] for (u, v, d) in G.edges(data=True)]

# Vẽ các node, nhãn và cạnh của đồ thị
nx.draw_networkx_nodes(G, pos, node_size=1000, node_color='lightblue')
nx.draw_networkx_labels(G, pos, font_size=9)
nx.draw_networkx_edges(G, pos, edge_color=weights, edge_cmap=plt.cm.plasma, arrows=True, width=2)

# Hiển thị tiêu đề và ẩn trục
plt.title('Biểu đồ mạng: Các luật kết hợp sản phẩm', fontsize=16)
plt.axis('off')
plt.show()